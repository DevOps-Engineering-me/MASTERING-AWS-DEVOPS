# jq Pipeline Execution Guide

A simple guide to understanding how jq processes JSON data step-by-step.

---

## Table of Contents
- [Basic Concepts](#basic-concepts)
- [How jq Reads Files](#how-jq-reads-files)
- [Pipeline Operators](#pipeline-operators)
- [Common Operations](#common-operations)
- [The check_existing_vpc Function](#the-check_existing_vpc-function)
- [Quick Reference](#quick-reference)

---

## Basic Concepts

### What is jq?
jq is a command-line JSON processor that filters and transforms JSON data.

### Pipeline Flow
```
Input â†’ Filter 1 â†’ Filter 2 â†’ Filter 3 â†’ Output
```

Each filter processes data and passes results to the next filter using the pipe operator `|`.

---

## How jq Reads Files

### Method 1: Using Pipe (2 processes)
```bash
cat file.json | jq '.[]'
```
**Flow:** `cat reads file â†’ outputs to STDOUT â†’ pipe â†’ jq reads from STDIN`

### Method 2: Direct File (1 process) âœ… Better
```bash
jq '.[]' file.json
```
**Flow:** `jq opens file directly â†’ reads content â†’ processes`

### Why Direct File is Better
- **Faster**: Only 1 process instead of 2
- **More efficient**: No pipe overhead
- **Clearer errors**: Know exactly what failed

---

## Pipeline Operators

### The Pipe `|`
Passes output from left side to right side.

```bash
jq '.[] | select(.name == "test") | .id' data.json
```

**Step by step:**
1. `.[]` â†’ Unpacks array into individual objects
2. `select(...)` â†’ Filters objects that match condition
3. `.id` â†’ Extracts the id field

### Example Execution

**Input JSON:**
```json
[
  {"name": "test", "id": 1},
  {"name": "prod", "id": 2},
  {"name": "test", "id": 3}
]
```

**Step 1:** `.[]` unpacks
```json
{"name": "test", "id": 1}
{"name": "prod", "id": 2}
{"name": "test", "id": 3}
```

**Step 2:** `select(.name == "test")` filters
```json
{"name": "test", "id": 1}
{"name": "test", "id": 3}
```

**Step 3:** `.id` extracts
```
1
3
```

---

## Common Operations

### 1. Unpack Array: `.[]`
```bash
# Input: [1, 2, 3]
jq '.[]'
# Output: 1
#         2
#         3
```

### 2. Filter: `select(condition)`
```bash
# Keep only objects where .age > 18
jq '.[] | select(.age > 18)'
```

### 3. Extract Field: `.fieldname`
```bash
# Get just the name field
jq '.[] | .name'
```

### 4. Map and Transform: `map()`
```bash
# Apply operation to all elements, keeps result as array
jq 'map(select(.active == true))'
```

### 5. Count: `length`
```bash
# Count array elements
jq 'map(select(.status == "active")) | length'
```

### 6. Pass Variables: `--arg`
```bash
# Pass shell variable to jq
jq --arg name "John" '.[] | select(.name == $name)'
```

### 7. Raw Output: `-r`
```bash
# Remove quotes from strings
jq -r '.name'
# With -r:  John
# Without:  "John"
```

---

## The check_existing_vpc Function

### Sample Data
**Variables:**
```bash
VPC_NAME="Poridhi-VPC-02"
VPC_CIDR="10.0.0.0/16"
JSON_FILE="vpc_inventory.json"
```

**JSON File:**
```json
[
  {"vpc_name": "Poridhi-VPC-01", "cidr": "10.1.0.0/16", "vpc_id": "vpc-123"},
  {"vpc_name": "Poridhi-VPC-02", "cidr": "10.2.0.0/16", "vpc_id": "vpc-456"},
  {"vpc_name": "Poridhi-VPC-03", "cidr": "10.0.0.0/16", "vpc_id": "vpc-789"}
]
```

---

### Part 1: Check if VPC Name Exists

**Command:**
```bash
local name_exists=$(jq -r --arg name "$VPC_NAME" --arg cidr "$VPC_CIDR" \
    'map(select(.vpc_name == $name)) | length' "$JSON_FILE")
```

**Step-by-Step Execution:**

#### Step 1: Pass Variables to jq
```bash
--arg name "Poridhi-VPC-02"  # Creates $name variable in jq
--arg cidr "10.0.0.0/16"     # Creates $cidr variable in jq
```

#### Step 2: jq Opens and Reads File
```
jq internally opens "vpc_inventory.json" and reads the JSON content
```

#### Step 3: `map(select(.vpc_name == $name))`

**Iteration 1:**
- Object: `{"vpc_name": "Poridhi-VPC-01", ...}`
- Check: `"Poridhi-VPC-01" == "Poridhi-VPC-02"` â†’ FALSE âœ—
- Result: Filtered out

**Iteration 2:**
- Object: `{"vpc_name": "Poridhi-VPC-02", ...}`
- Check: `"Poridhi-VPC-02" == "Poridhi-VPC-02"` â†’ TRUE âœ“
- Result: **Kept**

**Iteration 3:**
- Object: `{"vpc_name": "Poridhi-VPC-03", ...}`
- Check: `"Poridhi-VPC-03" == "Poridhi-VPC-02"` â†’ FALSE âœ—
- Result: Filtered out

**After map():**
```json
[
  {"vpc_name": "Poridhi-VPC-02", "cidr": "10.2.0.0/16", "vpc_id": "vpc-456"}
]
```

#### Step 4: `| length`
Counts array elements â†’ Result: `1`

#### Step 5: Store Result
```bash
name_exists=1  # 1 means name exists
```

---

### Part 2: Check if CIDR Exists

**Command:**
```bash
local cidr_exists=$(jq -r --arg name "$VPC_NAME" --arg cidr "$VPC_CIDR" \
    'map(select(.cidr == $cidr)) | length' "$JSON_FILE")
```

**Execution (similar to Part 1, but checking CIDR):**

**After filtering:**
```json
[
  {"vpc_name": "Poridhi-VPC-03", "cidr": "10.0.0.0/16", "vpc_id": "vpc-789"}
]
```

**Result:**
```bash
cidr_exists=1  # 1 means CIDR exists
```

---

### Part 3: If Name Exists, Show Details

**Command:**
```bash
if [ "$name_exists" -gt 0 ]; then
    echo "Warning: VPC with name '$VPC_NAME' already exists!"
    jq -r --arg name "$VPC_NAME" \
        'map(select(.vpc_name == $name)) | .[]' "$JSON_FILE"
    return 1
fi
```

**Pipeline Breakdown:**

#### `map(select(.vpc_name == $name))`
Filters to matching VPC â†’ Returns array with 1 object

#### `| .[]`
Unpacks the array, removes outer brackets

**Output:**
```json
{
  "vpc_name": "Poridhi-VPC-02",
  "cidr": "10.2.0.0/16",
  "vpc_id": "vpc-456"
}
```

#### `return 1`
Exit function with error code (conflict found)

---

### Part 4: If CIDR Exists, Show Details

**Same logic as Part 3, but for CIDR:**

```bash
if [ "$cidr_exists" -gt 0 ]; then
    echo "Warning: VPC with CIDR '$VPC_CIDR' already exists!"
    jq -r --arg cidr "$VPC_CIDR" \
        'map(select(.cidr == $cidr)) | .[]' "$JSON_FILE"
    return 1
fi
```

---

### Part 5: No Conflicts

```bash
return 0  # Success - safe to create VPC
```

---

## Quick Reference

### Basic Syntax
```bash
jq [OPTIONS] 'FILTER' [FILE]
```

### Common Filters

| Filter | Description | Example |
|--------|-------------|---------|
| `.` | Current input | `jq '.'` |
| `.field` | Extract field | `jq '.name'` |
| `.[]` | Unpack array | `jq '.[]'` |
| `.[0]` | First element | `jq '.[0]'` |
| `.[-1]` | Last element | `jq '.[-1]'` |
| `select()` | Filter by condition | `jq '.[] \| select(.age > 18)'` |
| `map()` | Transform array | `jq 'map(.name)'` |
| `length` | Count elements | `jq 'length'` |

### Common Options

| Option | Description | Example |
|--------|-------------|---------|
| `-r` | Raw output (no quotes) | `jq -r '.name'` |
| `--arg` | Pass variable | `jq --arg x "value" '.[] \| select(.id == $x)'` |
| `-c` | Compact output | `jq -c '.'` |
| `-S` | Sort keys | `jq -S '.'` |

### Comparison Operators

| Operator | Meaning |
|----------|---------|
| `==` | Equal |
| `!=` | Not equal |
| `>` | Greater than |
| `<` | Less than |
| `>=` | Greater or equal |
| `<=` | Less or equal |

### String Functions

| Function | Description |
|----------|-------------|
| `contains("text")` | Check if contains substring |
| `startswith("text")` | Check if starts with |
| `endswith("text")` | Check if ends with |

---

## Key Takeaways

1. **Pipe `|` connects filters** - output of left becomes input of right
2. **jq can read files directly** - no need for `cat`
3. **Each stage transforms data** - understand what each filter outputs
4. **`map()` keeps arrays** - `.[]` unpacks them
5. **`select()` filters** - only matching items pass through
6. **`--arg` passes variables safely** - prevents injection issues
7. **`-r` for clean output** - removes JSON quotes from strings

---

## Practice Examples

### Find all active users
```bash
jq '.[] | select(.status == "active") | .username' users.json
```

### Count items by category
```bash
jq 'map(select(.category == "electronics")) | length' products.json
```

### Extract specific fields
```bash
jq '.[] | {name: .name, email: .email}' contacts.json
```

### Check if value exists
```bash
exists=$(jq 'map(select(.id == "123")) | length' data.json)
if [ "$exists" -gt 0 ]; then
    echo "Found!"
fi
```

---

**Happy JSON processing! ðŸŽ¯**